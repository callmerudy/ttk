<html>
<head>
<link href="ttk.css" type="text/css" rel="StyleSheet">
</head>


<body>

[ <a href="#sourceparser">source parser</a>
| <a href="#documentparser">document parser</a>
| <a href="#preprocessing">preprocessing</a>
| <a href="#btime">BTime</a>
| <a href="#evita">Evita</a>
| <a href="#identifiers">tag identifiers</a>
| <a href="#">More</a>
]


<a name="sourceparser"/>
<h3>Splitting the source into read-only text and annotations</h3>

<p>An input document is first processed by the SourceParser() in
docmodel/source_parser.py.</p>

<img src="./images/sourceparser.jpg" width="660">

<p> The result is an instance of SourceDoc in which the source and tags are split. The value of
<code>source</code> is a read-only unicode string, which is created using the default
settings of the Expat parser. The <code>tags</code> variable contains a repository of the
tags in the input document. This repository is intended to be read-only, TTK processing
will not add to this repository, rather, it will add tags to another repository (or
repositories). A <code>SourceDoc</code> instance has a few more instance variables of
interest:</p>

<ol>
<li>filename: the name of the input file
<li>xmldecl: the xmldeclaration as a triple (version, encoding, standalone)</li>
<li>comments: a dictionary of comments, indexed on character offset
<li>processing_instructions: a dictionary of processing instructions, indexed on character offset
</ol>

<p>PROBLEM: later processing stages replace unicode strings with strings, need to find
where this happens. This does not happen for the value of <code>source</code> but for the
strings inside of some other component, not sure which one, also not sure whether this is
actually a problem or something that can be ignored.</p>


<a name="documentparser"/>
<h3>Document parsing</h3>

<p>The code in docmodel/parsers.py parses the overall structure of the document. There
are going to be parsers for all data types and genres that the toolkit needs to deal
with. It is not clear yet how exactly this will be done since data types and genres can be
orthogonal. The example here focuses on the simple case of the default parser.</p>

<img src="images/defaultparser.jpg" width="700">

<p>The DefaultParser() takes a SourceDoc and creates an instance of TarsqiDocument, which
contains the read-only SourceDoc. The <code>elements</code> variable contains a list of
instances of TarsqiDocElement or one of its subclasses. For the default parser, this list
has only one element, a TarsqiDocParagraph. The <code>metadata</code> variable contains a
dictionary of meta data. With the default parser, the only element added is 'dct', the
document creation time, which is set to the present day. The <code>xmldoc</code> variable
will at some point be deprecated, but is kept around because most modules use it as an
interface. For the default parser, <code>xmldoc</code> contains the XmlDocument for the
single Tarsqi paragraph.</p>

<p>Document structure is now implemented as a flat list with, at this point, only one kind
of element, instances of TarsqiDocParagraph. In the future, this will also have other
elements like TarsqiSectionHeader.</p>

<img src="images/tarsqiparagraph.jpg" width="340">

<p>A TarsqiDocParagraph has seven instance variables: <code>id</code> is a unique
identifier, <code>begin</code> and <code>end</code> contain the begin and end offsets in
the source text, <code>doc</code> is the TarsqiDocument that the paragraph is embedded in
(which gives access to the source text, <code>source_tags</code> is a TagRepository with
tags from the source, containing only those tags that either fully contain the paragraph
or are fully contained in it, <code>tarsqi_tags</code> is a TagRepository for added tags,
and <code>doctree</code> contains the Document for the paragraph. The Tag instances in the
tag repositories have offsets referring to the source text, that is, the unicode string
in <code>tarsqidoc.source.text</code>, where <code>tarsqidoc</code> is an instance of
TarsqiDocument. </p>



<a name="preprocessing"/>
<h3>Pre-Processing</h3>

<p>Preprocessing is the same no matter what the genre or the document type. All
TarsqiDocElements in the elements variable of the TarsqiDocument are processed, here shown
for the TarsqiDocument that is created by the DefaultParser.</p>

<img src="images/preprocessing.jpg" width="480">

<p>The unicode string in the text instance variable from the single TarsqiDocParagraph is
sent through the preprocessing chain. The result of tokenizing, tagging and chunking is a
shallow parse, a list of sentences where each sentence contains lexical items, noun chunks
or verb chunks. Chunks contain lexical items only, no embedded chunks.</p>

<p>Note that the tokenizer works on substrings of the document (those embedded in the
individual elements) and assigns offsets relative to those substrings. After tokenization,
these offsets are adjusted and made relatie to the start of the document.</p>

<p>The <code>export</code> function takes this structure and exports tags to the
TagRepository in <code>tarsqi_tags</code>, using unique identifiers for lexical items
(lid), sentences (sid) and noun groups and verb groups (who share the cid identifier). The
export code generates identifiers for tokens, chunks and sentences that are unique to at
least the document and possibly even across documents if an entire directory is parsed. It
also creates an instance of Document and puts it in the <code>doctree</code>
variable. (NOTE: this is not done yet as of 10/31/2011).</p>



<a name="btime"/>
<h3>BTime</h3>

<p>Currently, BTime works the same on all TarsqiDocElements. It is given a list of list of
unicode strings, that is, a list of sentences. It returns a list of tuples where each
tuple includes the positions in the input list that were recognized as times and a timex
tag, which contains. amingst other things, the normalized value.</p>



<a name="evita"/>
<h3>Evita</h3>




<a name="identifiers"/>
<h3>Tag Identifiers</h3>

<p>All Tarsqi tags added by the system have identifiers that are unique to the document
and the tag type. The identifiers consist of a tag-specific prefix and an integer. The
prefixes and the tags they go with are listed in the table below.</p>

<table border=1 cellspacing=0 cellpadding=3 class="example">
<tr>
  <td>l
  <td>&lt;lex&gt;
  <td>The lexical tokens from the base segmentation. Refer to character offsets.
<tr>
  <td>c
  <td>&lt;ng&gt;, &lt;vg&gt;
  <td>Chunks. Refer to character offsets and lex ids.
<tr>
  <td>s  
  <td>&lt;s&gt;
  <td>Sentence boundaries. Refer to character offsets and lex ids.
<tr>
  <td>t  
  <td>&lt;timex3&gt;
  <td>BTime timex tags.
<tr>
  <td>e  
  <td>&lt;event&gt;
  <td>Evita event tags, notice the absence of the depricated makeinstance tag.
<tr>
  <td>al  
  <td>&lt;alink&gt;
  <td rowspan="3" valign="top">The three relation tags. These can only refer to event ids or timex ids.
<tr>
  <td>sl
  <td>&lt;slink&gt;
<tr>
  <td>tl
  <td>&lt;tlink&gt;
</table>

<p>Tarsqi tags refer to character offsets in the primary data or to identifiers of other
Tarsqi tags, some tags refer to both. For these, the toolkit uses the LAF attibutes
anchors and targets. With the naming scheme above, the content of the target attribute,
which refers to a range, is always uniquely defined.</p>

<p>Tags that were in the source document are not expected to have ids, nor are they
added.</p>



</body>
</html>

